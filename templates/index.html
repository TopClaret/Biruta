<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reiniciar Serviço de Impressão</title>
    <style nonce="{{ csp_nonce }}">
        .container {
            background-color: #fff;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            width: 100%;
            max-width: 800px; /* Aumentado para acomodar o novo layout */
            margin: 20px;
        }

        .connection-config {
            background-color: #f0f2f5;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
            align-items: end;
        }

        .connection-config h2 {
            grid-column: 1 / -1; /* Ocupa todas as colunas */
            text-align: left;
            color: #34495e;
            margin-top: 0;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
        }

        .input-group label {
            font-size: 0.9em;
            color: #555;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .connection-config input[type="text"],
        .connection-config input[type="password"],
        .connection-config input[type="number"] {
            width: calc(100% - 20px);
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .connection-config button {
            grid-column: span 1; /* Pode ajustar conforme necessário */
            padding: 10px 15px;
            font-size: 0.9em;
            margin-top: 10px; /* Para alinhar com os inputs */
        }

        .tabs-container {
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            background-color: #f8f9fa;
            padding: 10px;
        }

        .tabs-header {
            display: flex;
            border-bottom: 1px solid #e0e0e0;
            margin-bottom: 10px;
        }

        .tab-button {
            background-color: #e9ecef;
            color: #495057;
            padding: 10px 15px;
            border: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s ease;
            margin-right: 2px;
        }

        .tab-button:hover {
            background-color: #dee2e6;
        }

        .tab-button.active {
            background-color: #fff;
            color: #3498db;
            border-bottom: 1px solid #fff;
            font-weight: bold;
        }

        .tab-pane {
            display: none;
            padding: 15px 0;
        }

        .tab-pane.active {
            display: block;
        }

        .filter-group {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }

        .filter-group label {
            margin-right: 10px;
            font-weight: bold;
            color: #555;
        }

        .filter-group input[type="text"] {
            flex-grow: 1;
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 0.9em;
        }

        /* Estilos existentes para botões, mensagens, printer-grid e service-grid */
        button {
            background-color: #3498db; /* Azul mais vibrante */
            color: white;
            padding: 12px 25px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1.1em;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        button:hover {
            background-color: #2980b9;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.25);
            transform: translateY(-2px);
        }
        button:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
            box-shadow: none;
            transform: none;
        }
        #message {
            margin-top: 20px;
            font-weight: bold;
            color: #333;
            text-align: left;
        }
        .success {
            color: #28a745;
        }
        .error {
            color: #dc3545;
        }
        .printer-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .printer-card {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            text-align: left;
            transition: transform 0.2s ease-in-out;
        }
        .printer-card:hover {
            transform: translateY(-5px);
        }
        .printer-card h4 {
            color: #34495e;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 5px;
        }
        .printer-card p {
            margin: 5px 0;
            color: #555;
            font-size: 0.9em;
        }
        .printer-card p strong {
            color: #333;
        }

        .service-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin-top: 15px;
            padding: 10px;
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .service-card {
            background-color: #ffffff;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            text-align: left;
            transition: transform 0.2s ease-in-out;
        }

        .service-card:hover {
            transform: translateY(-3px);
        }

        .service-card h4 {
            color: #34495e;
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 1em;
            border-bottom: 1px solid #eee;
            padding-bottom: 4px;
        }

        .service-card p {
            margin: 4px 0;
            color: #555;
            font-size: 0.85em;
        }

        .service-card p strong {
            color: #333;
        }

        .status-running {
            color: #28a745; /* Verde */
            font-weight: bold;
        }

        .status-stopped {
            color: #dc3545; /* Vermelho */
            font-weight: bold;
        }

        .status-paused {
            color: #ffc107; /* Amarelo/Laranja */
            font-weight: bold;
        }

        .status-pending, .status-start_pending, .status-stop_pending {
            color: #007bff; /* Azul */
            font-weight: bold;
        }

        .status-not_found, .status-error {
            color: #6c757d; /* Cinza */
            font-weight: bold;
        }

        #toastOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            align-items: center;
            justify-content: center;
            background: rgba(0, 0, 0, 0.3);
            z-index: 1000;
        }
        #toast {
            background: #ffffff;
            border-radius: 10px;
            padding: 16px 20px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.15);
            max-width: 460px;
            width: calc(100% - 40px);
            text-align: center;
            position: relative;
        }
        .toast-success {
            border-left: 6px solid #28a745;
        }
        .toast-error {
            border-left: 6px solid #dc3545;
        }
        .toast-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }
        .toast-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: #28a745;
            color: #fff;
            font-weight: bold;
            font-size: 18px;
        }
        .toast-title {
            font-weight: 700;
            color: #2f3941;
            margin: 10px 0 6px 0;
            font-size: 1.05em;
        }
        .toast-info {
            color: #6c757d;
            font-size: 0.95em;
        }
        #toastClose {
            background: transparent;
            border: none;
            font-size: 20px;
            line-height: 20px;
            color: #6c757d;
            cursor: pointer;
        }

    </style>
</head>
<body>
    <div class="container">
        <div id="toastOverlay">
            <div id="toast" class="toast-success">
                <div class="toast-header">
                    <span id="toastIcon" class="toast-icon">✓</span>
                    <button id="toastClose">×</button>
                </div>
                <div class="toast-title" id="toastTitle"></div>
                <div class="toast-info" id="toastInfo"></div>
            </div>
        </div>
        <div class="connection-config">
            <h2>Configurações de Conexão</h2>
            <div class="input-group">
                <label for="remoteHost">IP/Máquina:</label>
                <input type="text" id="remoteHost" placeholder="Nome do Host ou IP Remoto">
            </div>
            <div class="input-group">
                <label for="username">Usuário:</label>
                <input type="text" id="username" placeholder="Usuário (para acesso remoto)">
            </div>
            <div class="input-group">
                <label for="password">Senha:</label>
                <input type="password" id="password" placeholder="Senha (para acesso remoto)" autocomplete="new-password" autocapitalize="off" spellcheck="false">
            </div>
            <div class="input-group">
                <label for="domain">Domínio:</label>
                <input type="text" id="domain" placeholder="Domínio (opcional)">
            </div>
            
            <button id="connectButton">Conectar</button>
        </div>

        <p id="message"></p>

        <div class="tabs-container">
            <div class="tabs-header">
                <button class="tab-button active" data-tab="services">Serviços</button>
                <button class="tab-button" data-tab="printers">Impressoras</button>
                <button class="tab-button" data-tab="disk">Disco</button>
                <button class="tab-button" data-tab="ping">Ping</button>
            </div>
            <div class="tabs-content">
                <div id="services" class="tab-pane active">
                    <div class="filter-group">
                        <label for="serviceFilter">Filtro de Serviços:</label>
                        <input type="text" id="serviceFilter" placeholder="Filtrar serviços...">
                    </div>
                    <button id="restartButton">Reiniciar Serviços</button>
                    <div id="servicesOutput" class="service-grid"></div>
                </div>
                <div id="printers" class="tab-pane">
                    <button id="listPrintersButton">Listar Impressoras</button>
                    <div id="printersOutput" class="printer-grid"></div>
                </div>
                <div id="disk" class="tab-pane">
                    <p>Conteúdo da aba Disco</p>
                </div>
                <div id="ping" class="tab-pane">
                    <p>Conteúdo da aba Ping</p>
                </div>
            </div>
        </div>


    </div>

    <script nonce="{{ csp_nonce }}">
        let printerUpdateInterval = null;
        let serviceStatusInterval = null;
        let statusEventSource = null;
        let sseReconnectTimer = null;
        let serviceMonitorToken = null;
        function getCookie(name) {
            const match = document.cookie.match(new RegExp('(^| )' + name + '=([^;]+)'));
            return match ? match[2] : null;
        }
        function csrfHeaders() {
            const token = getCookie('XSRF-TOKEN');
            return token ? { 'X-CSRF-Token': token } : {};
        }
        document.getElementById('restartButton').addEventListener('click', async () => {
            const button = document.getElementById('restartButton');
            const message = document.getElementById('message');

            const servicesOutput = document.getElementById('servicesOutput');
            const remoteHost = document.getElementById('remoteHost').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            if (!remoteHost) {
                servicesOutput.innerHTML = '<p>Por favor, insira o IP/Máquina para listar os serviços.</p>';
                return;
            }

            button.disabled = true;
            message.textContent = 'Iniciando limpeza de trabalhos de impressão e reinício sequencial dos serviços...';
            message.className = ''; 

            try {
                // 1. Limpar trabalhos de impressão primeiro
                message.textContent = 'Limpando trabalhos de impressão...';
                const clearJobsResponse = await fetch('/clear_print_jobs', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...csrfHeaders()
                    },
                    body: JSON.stringify({ remote_host: remoteHost, username: username, password: password })
                });

                const clearJobsData = await clearJobsResponse.json();

                if (!clearJobsResponse.ok) {
                    message.textContent = clearJobsData.message || 'Erro desconhecido ao limpar trabalhos de impressão.';
                    message.className = 'error';
                    button.disabled = false;
                    return;
                }
                message.textContent = clearJobsData.message;
                message.className = 'success';
                
                // 2. Em seguida, reiniciar os serviços
                message.textContent = 'Reiniciando serviços sequencialmente...';
                const restartServicesResponse = await fetch('/restart_multiple_services', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...csrfHeaders()
                    },
                    body: JSON.stringify({ remote_host: remoteHost, username: username, password: password })
                });

                const restartServicesData = await restartServicesResponse.json();

                if (restartServicesResponse.ok) {
                    message.textContent = restartServicesData.message;
                    message.className = 'success';
                    fetchAndRenderServiceStatus();
                } else {
                    message.textContent = restartServicesData.message || 'Erro desconhecido ao iniciar o reinício sequencial.';
                    message.className = 'error';
                    if (restartServicesData.results) {
                        const errorDetails = restartServicesData.results.filter(res => res.status === 'error').map(res => `${res.service}: ${res.message}`).join('\n');
                        if (errorDetails) {
                            message.textContent += `\nDetalhes dos erros:\n${errorDetails}`;
                        }
                    }
                }
            } catch (error) {
                console.error('Erro na requisição:', error);
                message.textContent = 'Não foi possível conectar ao servidor. Certifique-se de que o aplicativo está rodando.';
                message.className = 'error';
            } finally {
                button.disabled = false;
            }
        });



        async function fetchAndRenderPrinters() {
            const button = document.getElementById('listPrintersButton');
            const message = document.getElementById('message');
            const printersOutput = document.getElementById('printersOutput');

            const remoteHost = document.getElementById('remoteHost').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            button.disabled = true;
            
            message.textContent = 'Listando impressoras...';
            message.className = '';
            // Não limpa o output para permitir atualização in-place

            try {
                const response = await fetch('/list_printers', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...csrfHeaders()
                    },
                    body: JSON.stringify({ remote_host: remoteHost, username: username, password: password })
                });

                const data = await response.json();

                if (response.ok) {
                    message.textContent = data.message;
                    message.className = 'success';
                    printersOutput.innerHTML = ''; // Limpa antes de renderizar para atualização
                    if (data.printers && data.printers.length > 0) {
                        const escapeHtml = s => String(s).replace(/[&<>"]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c]));
                        data.printers.forEach(printer => {
                            const printerCard = document.createElement('div');
                            printerCard.className = 'printer-card';
                            const nameEl = document.createElement('h4');
                            nameEl.textContent = printer.Name;
                            printerCard.appendChild(nameEl);
                            const makeP = (label, val) => {
                                const p = document.createElement('p');
                                const strong = document.createElement('strong');
                                strong.textContent = label;
                                p.appendChild(strong);
                                p.appendChild(document.createTextNode(' ' + (val == null ? 'N/A' : String(val))));
                                return p;
                            };
                            printerCard.appendChild(makeP('Localização:', printer.Location));
                            printerCard.appendChild(makeP('Driver:', printer.DriverName));
                            printerCard.appendChild(makeP('Porta:', printer.PortName));
                            printerCard.appendChild(makeP('Compartilhada:', printer.ShareName || 'Não'));
                            printerCard.appendChild(makeP('Status:', printer.Status || 'Desconhecido'));
                            printerCard.appendChild(makeP('Padrão:', printer.Default ? 'Sim' : 'Não'));
                            printerCard.appendChild(makeP('Local:', printer.Local ? 'Sim' : 'Não'));
                            printerCard.appendChild(makeP('Rede:', printer.Network ? 'Sim' : 'Não'));
                            printerCard.appendChild(makeP('Trabalhos Pendentes:', printer.JobCount));
                            printersOutput.appendChild(printerCard);
                        });
                    } else {
                        printersOutput.innerHTML = '<p>Nenhuma impressora encontrada.</p>';
                    }
                } else {
                    message.textContent = data.message || 'Erro desconhecido ao listar impressoras.';
                    message.className = 'error';

                }
            } catch (error) {
                console.error('Erro na requisição:', error);
                message.textContent = 'Não foi possível conectar ao servidor para listar impressoras. Certifique-se de que o aplicativo está rodando.';
                message.className = 'error';

            } finally {
                button.disabled = false;
            }
        }

        document.getElementById('listPrintersButton').addEventListener('click', () => {
            // Limpa qualquer intervalo existente antes de iniciar um novo
            if (printerUpdateInterval) {
                clearInterval(printerUpdateInterval);
            }
            fetchAndRenderPrinters(); // Chama imediatamente
        });

        // Função para buscar e renderizar o status dos serviços
        async function fetchAndRenderServiceStatus() {
            const servicesOutput = document.getElementById('servicesOutput');
            const remoteHost = document.getElementById('remoteHost').value;
            const username = document.getElementById('username').value;
            const password = document.getElementById('password').value;

            try {
                const response = await fetch('/get_services_status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        ...csrfHeaders()
                    },
                    body: JSON.stringify({ remote_host: remoteHost, username: username, password: password })
                });

                const data = await response.json();

                if (response.ok) {
                    servicesOutput.innerHTML = ''; // Limpa antes de renderizar
                    if (data.services && data.services.length > 0) {
                        data.services.forEach(service => {
                            const serviceCard = document.createElement('div');
                            serviceCard.className = 'service-card';
                            const statusClass = `status-${service.status.toLowerCase().replace(/ /g, '_')}`;
                            serviceCard.innerHTML = `
                                <h4>${service.name}</h4>
                                <p>Status: <span class="${statusClass}">${service.status}</span></p>
                            `;
                            servicesOutput.appendChild(serviceCard);
                        });
                    } else {
                        servicesOutput.innerHTML = '<p>Nenhum serviço encontrado ou monitorado.</p>';
                    }
                } else {
                    console.error('Erro ao buscar status dos serviços:', data.message);
                    servicesOutput.innerHTML = `<p class="error">Erro ao carregar status dos serviços: ${data.message || 'Erro desconhecido'}</p>`;
                }
            } catch (error) {
                console.error('Erro na requisição de status dos serviços:', error);
                servicesOutput.innerHTML = '<p class="error">Não foi possível conectar ao servidor para obter o status dos serviços.</p>';
            }
        }

        function renderServiceList(services) {
            const servicesOutput = document.getElementById('servicesOutput');
            servicesOutput.innerHTML = '';
            if (services && services.length > 0) {
                services.forEach(service => {
                    const serviceCard = document.createElement('div');
                    serviceCard.className = 'service-card';
                    const statusClass = `status-${service.status.toLowerCase().replace(/ /g, '_')}`;
                    const progress = statusToProgress(service.status);
                    const color = statusToColor(service.status);
                    serviceCard.innerHTML = `
                                <h4>${service.name}</h4>
                                <p>Status: <span class="${statusClass}">${service.status}</span></p>
                                <div class="service-progress" style="background:#eee;height:6px;border-radius:3px;">
                                    <div class="service-progress-bar" style="width:${progress}%;height:6px;background:${color};border-radius:3px;"></div>
                                </div>
                            `;
                    servicesOutput.appendChild(serviceCard);
                });
            } else {
                servicesOutput.innerHTML = '<p>Nenhum serviço encontrado ou monitorado.</p>';
            }
        }

        function statusToProgress(status) {
            const s = String(status).toLowerCase();
            if (s.includes('running')) return 100;
            if (s.includes('start') && s.includes('pending')) return 75;
            if (s.includes('stopped')) return 50;
            if (s.includes('stop') && s.includes('pending')) return 25;
            if (s.includes('error')) return 0;
            return 0;
        }

        function statusToColor(status) {
            const s = String(status).toLowerCase();
            if (s.includes('running')) return '#28a745';
            if (s.includes('start') && s.includes('pending')) return '#ffc107';
            if (s.includes('stopped')) return '#6c757d';
            if (s.includes('stop') && s.includes('pending')) return '#ffc107';
            if (s.includes('error')) return '#dc3545';
            return '#6c757d';
        }

        async function startServiceMonitorIfNeeded() {
            const remoteHost = document.getElementById('remoteHost').value.trim();
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            if (!remoteHost) {
                return null;
            }
            try {
                const resp = await fetch('/start_service_monitor', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...csrfHeaders() },
                    body: JSON.stringify({ remote_host: remoteHost, username, password })
                });
                const data = await resp.json();
                if (resp.ok && data.status === 'success') {
                    serviceMonitorToken = data.token;
                    return serviceMonitorToken;
                }
            } catch (e) {}
            return null;
        }

        async function connectServiceStatusEvents() {
            if (statusEventSource) return;
            let url = '/events/services_status';
            if (!serviceMonitorToken) {
                await startServiceMonitorIfNeeded();
            }
            if (serviceMonitorToken) {
                url = `/events/services_status_by_token?token=${serviceMonitorToken}`;
            }
            statusEventSource = new EventSource(url);
            statusEventSource.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    if (data && data.all && data.all.length) {
                        renderServiceList(data.all);
                    }
                    if (data && data.changed && data.changed.length > 0) {
                        const now = new Date();
                        const info = data.changed.map(c => `${c.service}: ${c.status} (${now.toLocaleString()})`).join('<br>');
                        data.changed.forEach(c => {
                            const cards = document.querySelectorAll('#servicesOutput .service-card');
                            cards.forEach(card => {
                                const name = card.querySelector('h4').textContent;
                                if (name === c.service) {
                                    const span = card.querySelector('span');
                                    const cls = `status-${String(c.status).toLowerCase().replace(/ /g, '_')}`;
                                    span.textContent = c.status;
                                    span.className = cls;
                                    const bar = card.querySelector('.service-progress-bar');
                                    if (bar) {
                                        bar.style.width = statusToProgress(c.status) + '%';
                                        bar.style.background = statusToColor(c.status);
                                    }
                                }
                            });
                        });
                    }
                } catch (_) {}
            };
            statusEventSource.onerror = () => {
                if (statusEventSource) {
                    statusEventSource.close();
                    statusEventSource = null;
                }
                if (!sseReconnectTimer) {
                    sseReconnectTimer = setTimeout(() => {
                        sseReconnectTimer = null;
                        connectServiceStatusEvents();
                    }, 2000);
                }
            };
        }

        function disconnectServiceStatusEvents() {
            if (statusEventSource) {
                statusEventSource.close();
                statusEventSource = null;
            }
            if (sseReconnectTimer) {
                clearTimeout(sseReconnectTimer);
                sseReconnectTimer = null;
            }
        }

        // Chama a função de status dos serviços ao carregar a página
        document.addEventListener('DOMContentLoaded', () => {
            connectServiceStatusEvents();
        });

        // Adiciona event listeners para os botões das abas
        document.querySelectorAll('.tab-button').forEach(button => {
            button.addEventListener('click', () => {
                const tabId = button.dataset.tab;
                showTab(tabId);
            });
        });

        function showTab(tabId) {
            // Remove a classe 'active' de todos os botões e painéis
            document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));

            // Adiciona a classe 'active' ao botão e painel da aba selecionada
            document.querySelector(`.tab-button[data-tab="${tabId}"]`).classList.add('active');
            document.getElementById(tabId).classList.add('active');

            // Lógica específica para cada aba ao ser ativada
            if (tabId === 'services') {
                connectServiceStatusEvents();
                if (serviceStatusInterval) {
                    clearInterval(serviceStatusInterval);
                    serviceStatusInterval = null;
                }
            } else {
                disconnectServiceStatusEvents();
            }

            if (tabId === 'printers') {
                // Não inicia o intervalo automaticamente, apenas quando o botão é clicado
                // fetchAndRenderPrinters(); 
            } else {
                clearInterval(printerUpdateInterval);
                printerUpdateInterval = null;
            }
        }

        const toastOverlay = document.getElementById('toastOverlay');
        const toast = document.getElementById('toast');
        const toastTitle = document.getElementById('toastTitle');
        const toastInfo = document.getElementById('toastInfo');
        const toastIcon = document.getElementById('toastIcon');
        const toastClose = document.getElementById('toastClose');
        let toastTimer = null;

        function showToast(type, title, info, autoHideMs = 5000) {
            toast.className = type === 'success' ? 'toast-success' : 'toast-error';
            toastIcon.textContent = type === 'success' ? '✓' : '!';
            toastIcon.style.background = type === 'success' ? '#28a745' : '#dc3545';
            toastTitle.textContent = title;
            toastInfo.innerHTML = info;
            toastOverlay.style.display = 'flex';
            if (toastTimer) {
                clearTimeout(toastTimer);
            }
            if (autoHideMs && autoHideMs > 0) {
                toastTimer = setTimeout(() => hideToast(), autoHideMs);
            }
        }

        function hideToast() {
            toastOverlay.style.display = 'none';
            if (toastTimer) {
                clearTimeout(toastTimer);
                toastTimer = null;
            }
        }

        toastClose.addEventListener('click', hideToast);

        document.getElementById('connectButton').addEventListener('click', async () => {
            const remoteHost = document.getElementById('remoteHost').value.trim();
            const usernameInput = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const domain = document.getElementById('domain').value.trim();
            const connectBtn = document.getElementById('connectButton');
            const messageElement = document.getElementById('message');

            const composedUser = domain ? `${domain}\\${usernameInput}` : usernameInput;

            if (!remoteHost || !usernameInput || !password) {
                messageElement.textContent = 'Informe IP, usuário e senha.';
                messageElement.className = 'error';
                return;
            }

            connectBtn.disabled = true;
            messageElement.textContent = 'Conectando...';
            messageElement.className = '';

            try {
                const response = await fetch('/test_wmi', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', ...csrfHeaders() },
                    body: JSON.stringify({ remote_host: remoteHost, username: composedUser, password })
                });
                const data = await response.json();
                const now = new Date();
                const infoHtml = `IP: ${remoteHost}<br>Data/Hora: ${now.toLocaleString()}<br>Status: ${response.ok ? 'Conectado' : 'Erro'}`;
                if (response.ok && data.status === 'success') {
                    messageElement.textContent = data.message;
                    messageElement.className = 'success';
                    fetchAndRenderServiceStatus();
                } else {
                    const errMsg = data && data.message ? data.message : 'Falha ao conectar.';
                    messageElement.textContent = errMsg;
                    messageElement.className = 'error';
                }
            } catch (e) {
                const now = new Date();
                const infoHtml = `IP: ${remoteHost}<br>Data/Hora: ${now.toLocaleString()}<br>Status: Erro`;
                messageElement.textContent = 'Não foi possível conectar ao servidor. Certifique-se de que o aplicativo está rodando.';
                messageElement.className = 'error';
            } finally {
                connectBtn.disabled = false;
            }
        });

        // Event listener para o filtro de serviços
        document.getElementById('serviceFilter').addEventListener('keyup', (event) => {
            const filterText = event.target.value.toLowerCase();
            const serviceCards = document.querySelectorAll('#servicesOutput .service-card');
            serviceCards.forEach(card => {
                const serviceName = card.querySelector('h4').textContent.toLowerCase();
                if (serviceName.includes(filterText)) {
                    card.style.display = 'block';
                } else {
                    card.style.display = 'none';
                }
            });
        });

    </script>
</body>
</html>